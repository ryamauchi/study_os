アセンブラをちょっと理解する。

まず以下のようなレジスタがある
    AX: アキュムレータ
    CX: カウンタ
    DX: データ
    BX: ベース
    SP: スタックポインタ
    BP: ベースポインタ
    SI: ソースインデックス
    DI: デスティネーションインデックス
Xがついてるのは 8bit から拡張された(extended)もので、 16bit あるらしい。
上 AH, 下 AL みたいに分けて使うこともできるようだ。
ちなみに 32bit では EAX(extended A extended), 64bit では RAX のように名前がついているとのこと。
更に上記以外にセグメントレジスタというものがあり、 ES, CS, SS, DS, FS, GS など名前がついている。
このセグメントレジスタへの代入はレジスタからしかできないんじゃないかと睨んでいるが、本当かどうかはまだわからない。

アセンブラの命令としては次のようなものがある。
    MOV:    代入
    ADD:    加算
    CMP:    比較
    JE:     イコールならジャンプ
    JMP:    ジャンプ
MOV AL,BYTE [SI] => これはレジスタ AL にメモリの SI 番地の１バイトを書き込めという意味になる。
AL は１バイトと決まっているので、 BYTE は省略可能。
MOV BYTE [678],123 ならメモリの 678 番地に 123 を書けという意味。
ところで、メモリの「番地」に対応するのは（『OS自作入門』では） 8bit という認識でよいのだろうか。
とするなら BYTE の代わりに DWORD などを使った場合は、指定した番地を「先頭にして」 Nbit 書き込まれる？（どうもそうっぽい）

ORG や DB, DW などはプロセッサが実行する命令ではなく、アセンブラに指示を与える命令で、「疑似命令」というらしい。

参考： http://www.elc.ees.saitama-u.ac.jp/ITO/Ex3/asm.html


去年ここをやったときは筆者の用意したツールを使わず、必要なツール群を別で用意したためいろいろ手間取ったが、今回は素直に用意されていたものを使ったためすんなり進んだ。
余裕があったら nasm 用に書き換えてみよう。
